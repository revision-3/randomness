package randomness

import (
	"math"
	"testing"
)

func TestBitArray(t *testing.T) {
	t.Run("Basic operations", func(t *testing.T) {
		// Test basic bit array operations
		bits := BitArray{true, false, true, false, true}

		// Test Length
		if bits.Length() != 5 {
			t.Errorf("Length() = %d, want 5", bits.Length())
		}

		// Test Get
		if !bits.Get(0) {
			t.Error("Get(0) = false, want true")
		}
		if bits.Get(1) {
			t.Error("Get(1) = true, want false")
		}

		// Test NumberAt
		// Note: NumberAt reads bits from right to left (LSB first)
		// For example, {true, false, true} is read as 101 in binary = 5
		if bits.NumberAt(0, 3) != 5 {
			t.Errorf("NumberAt(0, 3) = %d, want 5", bits.NumberAt(0, 3))
		}
		if bits.NumberAt(1, 3) != 2 {
			t.Errorf("NumberAt(1, 3) = %d, want 2", bits.NumberAt(1, 3))
		}
	})

	t.Run("Bit distribution", func(t *testing.T) {
		// Create a large bit array with random values
		size := 100000
		bits := make(BitArray, size)
		trueCount := 0
		falseCount := 0

		// Fill the array with random values
		for i := 0; i < size; i++ {
			bits[i] = GenerateTestRandomValue()%2 == 1
			if bits[i] {
				trueCount++
			} else {
				falseCount++
			}
		}

		// Check if the distribution is roughly 50/50
		expectedCount := size / 2
		tolerance := float64(size) * 0.05 // 5% tolerance

		if math.Abs(float64(trueCount)-float64(expectedCount)) > tolerance {
			t.Errorf("True count = %d, expected ≈ %d (deviation: %.2f%%)",
				trueCount, expectedCount, math.Abs(float64(trueCount)-float64(expectedCount))/float64(expectedCount)*100)
		}
		if math.Abs(float64(falseCount)-float64(expectedCount)) > tolerance {
			t.Errorf("False count = %d, expected ≈ %d (deviation: %.2f%%)",
				falseCount, expectedCount, math.Abs(float64(falseCount)-float64(expectedCount))/float64(expectedCount)*100)
		}
	})

	t.Run("NumberAt edge cases", func(t *testing.T) {
		// Test with all zeros
		zeros := make(BitArray, 8)
		if zeros.NumberAt(0, 8) != 0 {
			t.Errorf("NumberAt(0, 8) with all zeros = %d, want 0", zeros.NumberAt(0, 8))
		}

		// Test with all ones
		ones := make(BitArray, 8)
		for i := range ones {
			ones[i] = true
		}
		if ones.NumberAt(0, 8) != 255 { // 11111111 in binary = 255 (LSB first)
			t.Errorf("NumberAt(0, 8) with all ones = %d, want 255", ones.NumberAt(0, 8))
		}

		// Test with alternating bits
		alt := make(BitArray, 8)
		for i := range alt {
			alt[i] = i%2 == 0
		}
		if alt.NumberAt(0, 8) != 85 { // 10101010 in binary = 85 (LSB first)
			t.Errorf("NumberAt(0, 8) with alternating bits = %d, want 85", alt.NumberAt(0, 8))
		}
	})

	t.Run("NumberAt with different sizes", func(t *testing.T) {
		bits := BitArray{true, false, true, false, true, false, true, false}

		// Test different sizes
		// Note: NumberAt reads bits from right to left (LSB first)
		tests := []struct {
			start    int
			size     int
			expected uint64
		}{
			{0, 1, 1},  // 1
			{0, 2, 1},  // 01
			{0, 3, 5},  // 101
			{0, 4, 5},  // 0101
			{0, 8, 85}, // 10101010 (LSB first)
			{1, 3, 2},  // 010
			{2, 3, 5},  // 101
		}

		for _, tt := range tests {
			if got := bits.NumberAt(tt.start, tt.size); got != tt.expected {
				t.Errorf("NumberAt(%d, %d) = %d, want %d", tt.start, tt.size, got, tt.expected)
			}
		}
	})
}

func TestBits(t *testing.T) {
	t.Run("Basic functionality", func(t *testing.T) {
		// Test with a known value
		r := NewRandomness(TestStringForValue(uint8(0xAA))) // 10101010 in binary
		bits, err := r.Bits(8)
		if err != nil {
			t.Errorf("Bits(8) returned error: %v", err)
		}
		if bits.Length() != 8 {
			t.Errorf("Bits(8).Length() = %d, want 8", bits.Length())
		}
		// Check each bit
		expected := []bool{true, false, true, false, true, false, true, false}
		for i := range 8 {
			if bits.Get(i) != expected[i] {
				t.Errorf("Bits(8)[%d] = %v, want %v", i, bits.Get(i), expected[i])
			}
		}
	})

	t.Run("Distribution", func(t *testing.T) {
		// Test the distribution of bits generated by Bits()
		iterations := 100000
		bitCount := 1000 // Number of bits to generate per iteration
		trueCount := 0
		falseCount := 0

		for i := 0; i < iterations; i++ {
			r := NewRandomness(TestStringForValue(GenerateTestRandomValue()))
			bits, err := r.Bits(bitCount)
			if err != nil {
				t.Errorf("Bits(8) returned error: %v", err)
			}

			// Count true and false bits
			for j := 0; j < bits.Length(); j++ {
				if bits.Get(j) {
					trueCount++
				} else {
					falseCount++
				}
			}
		}

		// Check if the distribution is roughly 50/50
		totalBits := iterations * bitCount
		expectedCount := totalBits / 2
		tolerance := float64(totalBits) * 0.05 // 5% tolerance

		if math.Abs(float64(trueCount)-float64(expectedCount)) > tolerance {
			t.Errorf("True count = %d, expected ≈ %d (deviation: %.2f%%)",
				trueCount, expectedCount, math.Abs(float64(trueCount)-float64(expectedCount))/float64(expectedCount)*100)
		}
		if math.Abs(float64(falseCount)-float64(expectedCount)) > tolerance {
			t.Errorf("False count = %d, expected ≈ %d (deviation: %.2f%%)",
				falseCount, expectedCount, math.Abs(float64(falseCount)-float64(expectedCount))/float64(expectedCount)*100)
		}
	})

	t.Run("Byte alignment", func(t *testing.T) {
		// Test that Bits() reads whole bytes at a time
		// Using two known bytes: 0xAA (10101010) and 0x55 (01010101)
		r := NewRandomness(TestStringForValue(uint8(0xAA), uint8(0x55)))

		// Request 5 bits (should read from first byte)
		bits, err := r.Bits(5)
		if err != nil {
			t.Errorf("Bits(5) returned error: %v", err)
		}
		if bits.Length() != 5 {
			t.Errorf("Bits(5).Length() = %d, want 5", bits.Length())
		}
		// Verify first 5 bits match the first byte (0xAA)
		expected1 := []bool{true, false, true, false, true}
		for i := range 5 {
			if bits.Get(i) != expected1[i] {
				t.Errorf("First bits[%d] = %v, want %v", i, bits.Get(i), expected1[i])
			}
		}

		// Request 3 more bits (should read from second byte)
		moreBits, err := r.Bits(3)
		if err != nil {
			t.Errorf("Bits(3) returned error: %v", err)
		}
		if moreBits.Length() != 3 {
			t.Errorf("Bits(3).Length() = %d, want 3", moreBits.Length())
		}
		// Verify next 3 bits match the second byte (0x55)
		expected2 := []bool{false, true, false}
		for i := range 3 {
			if moreBits.Get(i) != expected2[i] {
				t.Errorf("Second bits[%d] = %v, want %v", i, moreBits.Get(i), expected2[i])
			}
		}
	})
}
